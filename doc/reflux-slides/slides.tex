\documentclass[default,pdf,colorBG,slideColor]{prosper}
\usepackage[T1]{fontenc}
\usepackage{epsfig}
\usepackage{pstricks}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {../fig/} }

\title{Runtime Environment for Flux}
\subtitle{{\small {\em prototype status}\\
LLNL-PRES-XXXXXX-DRAFT}}
\author{Jim Garlick}
\email{{\rm garlick@llnl.gov}}
\institution{Livermore Computing \\
             Lawrence Livermore National Laboratory}

\newcommand{\ngrm}{Flux}
\newcommand{\zMQ}{\O{}MQ}

% For listings:
\newcommand\Small{\fontsize{6}{6.2}\selectfont}
\newcommand\Smaller{\fontsize{5.5}{5.5}\selectfont}
\newcommand\realnumberstyle[1]{}
\makeatletter
\newcommand{\zebra}[2]{%
    {\realnumberstyle{#2}}%
    \begingroup
    \lst@basicstyle
    \ifodd\value{lstnumber}%
        \color{#1}%
        \rlap{\hspace*{\lst@numbersep}%
        \color@block{\linewidth}{\ht\strutbox}{\dp\strutbox}%
        }%
    \fi
    \endgroup
}
\makeatother

\slideCaption{\ngrm\ Progress Report, Sept. 17, 2013}

%\Logo(-1,-1){\epsfig{file=graphic/iccd_logotrans.ps,scale=0.15}}


\begin{document}

% ==========================================================================
\maketitle
% ==========================================================================

\begin{slide}{Overview}{\small
\begin{itemize}
  \item{brief introduction}
  \item{\zMQ\ patterns in a tree topology}
  \item{message broker plumbing}
  \item{plugin specifics}
  \item{putting it together: PMI/mvapich hello world}
  \item{resiliency}
  \item{design issues}
\end{itemize}
}\end{slide}

% ==========================================================================
\part{brief introduction}
% ==========================================================================

\begin{slide}{comms framework goals}{\small
\begin{itemize}
  \item{Build a foundation for \ngrm\ distributed components.}
  \item{A {\em comms session} contains each \ngrm\ job, and \\
	job hierarchy $\sim$ comms session hierarchy}
  \item{Rich comms within a session,\\
	No direct comms between sibling sessions,\\
        Limited comms between parent-child (through gateway)}
  \item{Parent session can create, resize, destroy child sessions}
\end{itemize}
}\end{slide}

\begin{slide}{modest initial prototype goals}{\small
\begin{itemize}
  \item{Launch a comms session as a Slurm job}
  \item{Launch and provide runtime services to
        lightweight jobs (e.g. MPI plus tools) sharing the session.}
  \item{(no recursive jobs, no persistent "bootstrap" comms)}
\end{itemize}
}\end{slide}

% ==========================================================================
\part{\zMQ\ patterns in a tree topology}
% ==========================================================================
\begin{slide}{\zMQ\ pub-sub events}{\small
\begin{minipage}{0.47\textwidth}
\begin{itemize}
  \item{one publisher, many subscribers}
  \item{we use EPGM reliable multicast,
        orthogonal to session reduction tree}
  \item{messages must include a tag frame to match against subscriptions}
  \item{our {\em events} are just a bare tag frame (so far)}
 \end{itemize}
\end{minipage}
\begin{minipage}{0.47\textwidth}
\begin{center}
  \includegraphics[scale=0.17]{reflux_event}
\end{center}
\end{minipage}
}\end{slide}

\begin{slide}{\zMQ\ simple dealer-router}{\small
\begin{minipage}{0.68\textwidth}
\begin{itemize}
  \item{dealer-router is for request-response}
  \item{C: dealer round-robins req to router}
  \item{S: router pushes peer addr on req}
  \item{S: handles req}
  \item{S: router strips peer addr off rep}
  \item{C: dealer receives rep}
  \item{dealer-router can be chained to arbitrary depth}
 \end{itemize}
\end{minipage}
\begin{minipage}{0.28\textwidth}
\begin{center}
  \includegraphics[scale=0.17]{reflux_dealer_router}
\end{center}
\end{minipage}
}\end{slide}

\begin{slide}{\zMQ\ dealer-router RPC}{\small
\begin{center}
  \includegraphics[scale=0.20]{reflux_rpc}
\end{center}
}\end{slide}

\begin{slide}{\zMQ\ reverse dealer-router RPC}{\small
\begin{center}
  \includegraphics[scale=0.18]{reflux_rev_rpc}
\end{center}
}\end{slide}

% ==========================================================================
\part{message broker plumbing}
% ==========================================================================

\begin{slide}{broker vs plugins}{\small
\begin{center}
  \includegraphics[scale=0.20]{reflux_arch_on_node}
\end{center}
}\end{slide}

\begin{slide}{broker vs broker}{\small
\begin{center}
  \includegraphics[scale=0.12]{reflux_arch_off_node}
\end{center}
}\end{slide}

\begin{slide}{routing}{\small
\begin{itemize}
  \item{routes are necssary to route requests downstream}
  \item{each cmb instance holds routes for all its downstream nodes}
  \item{routes are also installed for local plugins
        (technically also downstream)}
\end{itemize}
}\end{slide}


% ==========================================================================
\part{current prototype plugin interface}
% ==========================================================================

\begin{slide}{broker plugin design}{\small
\begin{itemize}
 \item{each plugin exists as a thread in message broker daemon}
 \item{plugins currently built statically into broker (easily fixed) }
 \item{plugin name is used to ``route'' requests}
 \item{plugin driver executes {\tt zloop} for each each plugin, and plugin
        registers one or more of the following callbacks:}
 \begin{itemize}
   \item{{\tt init} - called at daemon initialization}
   \item{{\tt fini} - called as daemon exits}
   \item{{\tt timeout} - called at configurable timeout interval}
   \item{{\tt recv} - called when a message is recvd for plugin}
 \end{itemize}
\end{itemize}
}\end{slide}

\begin{slide}{simplified example: echo server}
{\tiny\bf
\begin{lstlisting}[
 frame=shadowbox,
 rulesepcolor=\color{gray},
 numbers=left,
 numbersep=10pt,
 numberstyle=\tiny\zebra{gray!25},
 basicstyle=\Small\tt,
 ]
void handle_recv (plugin_ctx_t *p, zmsg_t **zmsg, zmsg_type_t type)
{
    json_object *o = NULL;
    if (cmb_msg_decode (*zmsg, NULL, &o) >= 0) {
        int i, repeat;
        const char *s;

        /* 'string' to echo is required. */
        if (util_json_object_get_string (o, "string", &s) < 0) {
            plugin_send_response_errnum (p, zmsg, EINVAL);
            goto out;
	}
        /* 'repeat' is optional */
        if (util_json_object_get_int (o, "repeat", &repeat) < 0)
            repeat = 1;
        for (i = 0; i < repeat; i++) {
            zmsg_t *z = zmsg_dup (*zmsg);
            json_object *resp = json_echo (s, p->conf->rank);
            plugin_send_response (p, &z, resp);
            json_object_put (resp);
        }
    }
out:
    if (o)
        json_object_put (o);
    zmsg_destroy (zmsg);
}
\end{lstlisting}
} \end{slide}

\begin{slide}{simplified example: echo client}
\vspace{-0.3in}
{\tiny\bf
\begin{lstlisting}[
 frame=shadowbox,
 rulesepcolor=\color{gray},
 numbers=left,
 numbersep=10pt,
 numberstyle=\tiny\zebra{gray!25},
 basicstyle=\Smaller\tt,
 ]
int main (int ac, char *av[])
{
    cmb_t c;
    json_object *o;
    int id, i, ncopies = 1;

    if (!(c = cmb_init ()))
	fatal ("Failed to open connect to cmb: %s\n", strerror (errno));

    if (ac > 3)
        ncopies = atoi (av[2]);

    o = json_object_new_object ();
    util_json_object_add_string (o, "string", av[1]);
    util_json_object_add_int (o, "repeat", ncopies);
    
    if (cmb_send_message (c, o, "echo") < 0)
        fatal ("cmb_send_message: %s\n", strerror (errno));

    for (i = 0; i < ncopies; i++) {
        char *tag, *s;
        zmsg_t *zmsg;

        if (!(zmsg = cmb_recv_zmsg (c, false)))
            fatal ("cmb_recv_zmsg: %s\n", strerror (errno));

        cmb_msg_decode (zmsg, &tag, &o);

        util_json_object_get_string (o, "string", &s);
        util_json_object_get_int (o, "id", &id);
        printf ("got reply %d from %d: %s\n", i+1, id, s);
        zmsg_destroy (&zmsg);
    }
    return (0);
}
\end{lstlisting}
} \end{slide}


% ==========================================================================
\part{plugins specifics}
% ==========================================================================

\begin{slide}{kvs overview}{\small
\begin{itemize}
  \item{in-memory only}
  \item{content-addressable store (SHA1 of content is key)}
  \item{"directories" also stored there (names$\rightarrow$SHA1 keys)}
  \item{master copy at node 0}
  \item{caches on other nodes, pull from parent (recursive),
        writeback with flush/commit}
  \item{consistency: multicast new root directory SHA1}
\end{itemize}
}\end{slide}

\begin{slide}{kvs update}{\small
\begin{center}
  \includegraphics[scale=0.20]{reflux_kvs_merkel}
\end{center}
}\end{slide}

\begin{slide}{kvs messages}{\tiny
\begin{tabular}{|l|l|l|}
\hline
{\em request } & {\em in } & {\em out }\\
\hline
kvs.get.<type> & \{"name":null\}
               & \{"name":val\}\\
kvs.put        & \{"name":val\}
               & \{"errnum":<errno>\}\\
kvs.flush      & -
               & \{"errnum":<errno>\}\\
kvs.commit     & \{"commit\_name":"..."\}
               & "<SHA1>,<vers>"\\
\hline
kvs.getroot    & -
               & "<SHA1>,<vers>"\\
kvs.name       & \{"name":"<SHA1>"\}
               & \{"name":null\}\\
kvs.store      & \{"<SHA1>":val\},
               & \{"<SHA1>":null\}\\
kvs.load       & \{"<SHA1>":null\}
               & \{"<SHA1>":val\}\\
\hline
\end{tabular}\\
\underline{Events}\\
{\tt event.kvs.setroot.<SHA1>,<vers>}\\
}\end{slide}

\begin{slide}{heartbeat}{\tiny
\begin{center}
  \includegraphics[scale=0.05]{reflux_generic}
\end{center}
\underline{Events}\\
{\tt event.sched.trigger.<epoch>}\\
\underline{Config}\\
{\tt conf.sync.period-sec = 1.5}\\
}\end{slide}

\begin{slide}{barriers}{\tiny
\begin{center}
  \includegraphics[scale=0.05]{reflux_generic}
\end{center}
\underline{Requests}\\
{\tt barrier.enter.name \{"name":"...", "nprocs":10, "count":1\}}\\
\underline{Events}\\
{\tt event.barrier.exit.<name>}\\
{\tt event.barrier.abort.<name>}\\
\underline{Config}\\
{\tt conf.barrier.reduction-timeout-msec = 1}\\
}\end{slide}

\begin{slide}{logging}{\tiny
\begin{center}
  \includegraphics[scale=0.05]{reflux_generic}
\end{center}
\underline{Requests}\\
{\tt log.msg \{"facility":"...", "level":m, "hopcount":n, "message":"..."\}}\\
{\tt log.dump.<facility>.<level>}\\
{\tt log.subscribe.<facility>.<level>}\\
{\tt log.unsubscribe.<facility>.<level>}\\
{\tt log.disconnect}\\
\underline{Events}\\
{\tt event.fault.<facility>}\\
\underline{Config}\\
{\tt conf.log.reduction-timeout-msec = 100}\\
{\tt conf.log.persist-level = "debug"}\\
{\tt conf.log.circular-buffer-entries = 100000}\\
}\end{slide}

\begin{slide}{liveness}{\tiny
\begin{center}
  \includegraphics[scale=0.05]{reflux_generic}
\end{center}
\underline{Requests}\\
{\tt live.hello.<rank>}\\
\underline{Events}\\
{\tt event.live.up.<rank>}\\
{\tt event.live.down.<rank>}\\
\underline{Config}\\
{\tt conf.live.missed-trigger-allow = 5}\\
{\tt conf.live.topology = [[1,2],[3,4],[5,6],[7]]}\\
{\tt conf.live.down = [2]}\\
}\end{slide}

% ==========================================================================
\part{putting it together}
% ==========================================================================

\begin{slide}{PMI Implementation}{\tiny
\begin{tabular}{|l|l|}
\hline
{\em PMIv1} & {\em Flux}\\
\hline
PMI\_Get\_rank(), PMI\_Get\_size() & \$SLURM\_PROCID, \$SLURM\_NTASKS\\
PMI\_Get\_appnum() & \$SLURM\_STEP\_ID\\
PMI\_Get\_clique\_size(), PMI\_Get\_clique\_ranks() & \$SLURM\_GTIDS\\
\hline
PMI\_KVS\_Get()    & cmb\_kvs\_get()\\
PMI\_KVS\_Put()    & cmb\_kvs\_put()\\
PMI\_KVS\_Commit() & cmb\_kvs\_flush()\\
PMI\_Barrier()     & cmb\_barrier(), cmb\_kvs\_commit()\\
\hline
\end{tabular}
We implement a collective commit in PMI\_Barrier(),
looking ahead to PMI2\_KVS\_Fence().
}\end{slide}

\begin{slide}{PMI Performance}{\small
\begin{center}
  \includegraphics[scale=0.80]{zmq-broker-hkvs}
\end{center}
}\end{slide}

% ==========================================================================
\part{resiliency}
% ==========================================================================

\begin{slide}{maintaining connectedness}{\small
\begin{itemize}
  \item{Upon receipt of event.live.down for parent, connect to backup parent
	(e.g. grandparent)}
  \item{Upon receipt of event.live.up for parent, return to regular parent.}
  \item{There is no support in the current prototype for retrying a request
        lost during recovery.}
  \item{We need to design an event based (not timeout based) retry mechanism.
        Requests need unique id's so duplicates can be discarded.}
\end{itemize}
}\end{slide}

\begin{slide}{Control node vulnerability}{\small
\begin{itemize}
  \item{Node 0 contains unique state (e.g. master KVS store)}
  \item{Loss of node 0 is fatal in the current prototype.}
\end{itemize}
}\end{slide}

% ==========================================================================
\part{design issues}
% ==========================================================================

\begin{slide}{open issues going forward}{\small
\begin{itemize}
  \item{handle messages lost during recovery}
  \item{recovery from node 0 failure}
  \item{flow control vs. unchecked \zMQ\ buffer growth}
  \item{deep security integration}
  \item{kvs persistence}
\end{itemize}
}\end{slide}

\end{document}
