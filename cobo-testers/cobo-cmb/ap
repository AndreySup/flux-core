#!/usr/bin/perl -w
use strict;
use Cwd;
use File::Find;
#use Getopt::Long qw/ :config gnu_getopt ignore_case /;

# Author: Adam Moody <moody20@llnl.gov>
# based on: http://www.stonehenge.com/merlyn/UnixReview/col27.html
# from: Randal L. Schwartz

# Subroutine: Print usage ===========================================

sub print_usage
{
    print "\n";
    print "  ap -- prints final absolute path to file or directory after expanding all symlinks\n";
    print "\n";
    print "  Usage:  ap [-cdlrh] <file> [file2 ...]\n";
    print "\n";
    print "  Options:\n";
    print "    -c  Disable tty coloring\n";
    print "    -d  List permissions of each component in final absolute path\n";
    print "    -l  List all intermediate links\n";
    print "    -r  Recursively search named directories printing broken symlinks\n";
    print "    -s  Output for scripts\n";
    print "    -h  Show this help screen\n";
    print "\n";
}

# Subroutine: Scans $PATH for file in $_[0] =========================

sub which
{
  # get the name of the item we're looking for (potential executable name)
  my $file = $_[0];

  # don't search through path if file contains slashes
  if ($file =~ m#/#) {
    return "";
  }

  # split paths by ':'
  my @paths = split(":", $ENV{PATH});
  foreach my $path (@paths) {
    # given a potential executable named file, get the full path to it
    my $full_path = "$path/$file";

    # check that the item exists, is a file, and is executable
    if (-e $full_path and -f $full_path and -x $full_path) {
      return $full_path;
    }
  }

  # couldn't find anything
  return "";
}

# Process arguments =================================================

# Initial values
my $flag_l = 0;
my $flag_d = 0;
my $flag_c = 0;
my $flag_r = 0;
my $flag_s = 0;
my $flag_h = 0;

# Process options
if(@ARGV and $ARGV[0] =~ /^-/) {
  # Flag will be set on any invalid option
  my $op_invalid = 0;

  # Strip off and record each option
  while(@ARGV and $ARGV[0] =~ /^-/) {
    my $op = shift @ARGV;
    my $op_valid=0;
    if($op =~ /^-.*l.*/) {$flag_l = 1; $op_valid = 1;}
    if($op =~ /^-.*d.*/) {$flag_d = 1; $op_valid = 1;}
    if($op =~ /^-.*c.*/) {$flag_c = 1; $op_valid = 1;}
    if($op =~ /^-.*r.*/) {$flag_r = 1; $op_valid = 1;}
    if($op =~ /^-.*s.*/) {$flag_s = 1; $op_valid = 1;}
    if($op =~ /^-.*h.*/) {$flag_h = 1; $op_valid = 1;}
    if(not $op_valid) { $op_invalid = 1; }
  }

  # Print usage and exit on any invalid option
  if($op_invalid) {
    print_usage();
    exit 1;
  }
}

#www.linuxjournal.com/article/8603 (color coding on screen)
my $c_cyan = "[0;36m";
my $c_red  = "[1;37;41m";
my $c_end  = "[0m";
if ($flag_c) {
  # turn off color coding
  $c_cyan = "";
  $c_red  = "";
  $c_end  = "";
}

# Trace down absolute path for target(s) ============================

# print usage if no arguments are given
if ($flag_h or (@ARGV < 1 and not $flag_r)) {
  print_usage();
  exit 0;
}

my @params = ();
if (not $flag_r) {
  @params = @ARGV;
} else {
  # with flag_r, items on the command line are directories
  # do a recursive search for broken links in these directories
  sub wanted { if ( -l && ! -e) { push @params, $File::Find::name; } }
  if (@ARGV == 0) { push @ARGV, '.'; }
  foreach my $dir (@ARGV) {
    chomp $dir;
    find(\&wanted, $dir);
  }
}

my $err = 0;

while (@params) {
  my $file = shift @params;
  
  # Get initial path to file =======
  # check that the file exists, according to following order:
  #  1) user named file exactly (starts with /, ./, or ../)
  #  2) file is an executable in $PATH
  #  3) file exists in the current working directory
  # Bail out and move on to next file, if not found
  if ($file !~ m#^/#) {
    my $file_cwd = join("/", cwd, $file);
    my $file_exe = which($file);
    chomp $file_exe;
    if (-e $file_exe or -l $file_exe) {
      $file = $file_exe;
    } elsif (-e $file_cwd or -l $file_cwd) {
      $file = $file_cwd;
    } else {
      print "File not found: $c_red$file$c_end\n";
      $err = 1;
      next;
    }
  }

  # if we still don't have an absolute path, it must be relative, so prepend the current working dir
  if ($file !~ m#^/#) {
    $file = join("/", cwd, $file);
  }

  # Traverse links to file =========
  my @right = split("/", $file);
  my @left  = shift @right;  # should be leading empty string, since $file is fully qualified

  my @links = ();
  while (@right) {
    my $item = shift @right;
    next if $item eq "." or $item eq "";

    if ($item eq "..") {
      pop @left if @left > 1;
      next;
    }

    my $link = readlink (join "/", @left, $item);

    if (defined $link) {
      # $item in the @left directory is a symlink, add the full name to the links list
      my $file = join "/", @left, $item, @right;
      push @links, $file;
      $file = join "/", @left, $item;

      # split the link into directory components, and shift off the leading blank if there is one (absolute path)
      my @parts = split "/", $link;
      if (@parts && ($parts[0] eq "")) { @left = shift @parts; }
      # push the new components in front of the remaing @right components
      unshift @right, @parts;

      my $target = join "/", @left, @right;
      if (not $flag_s) {
        if (-e $target or -l $target) {
          push @links, "$c_cyan$file$c_end --> $link\n";
        } else {
          push @links, "$c_red$file$c_end --> $c_red$link$c_end\n";
          $err = 1;
          push @left, @right;
          last;
        }
      }

      next;
    } else {
      # $item is just a normal file or directory within the @left directory,
      # append it and move on to the next component
      push @left, $item;
      next;
    }
  } # end while(@right)

  # Output =========================
  # print intermediate links
  if ($flag_l) {
    if (@links) {
      my $dirlist = join("\n", @links);
      if (not $flag_s) { print "\n"; }
      print $dirlist;
    }
    my $ap = join "/", @left;
    if (not -e $ap) {
      print "\nFile not found: $c_red$ap$c_end\n"; $err = 1;
    } else {
      print "\n$ap\n";
    }
  }

  # print permissions for each component of absolute path to file
  if ($flag_d) {
    @right = ();
    my @dirs = ();
    my $baddir = "";
    while (@left) {
      # pull the front directory component from @left and push it on the end of @right
      push @right, shift @left;
      next if (@right == 1 and $right[0] eq ""); #skip leading empty string
      my $dir = join "/", @right;
      if (-e $dir) { push @dirs, $dir; }
      else { $baddir = $dir; last; }
    }
    my $dirlist = join(" ", @dirs);
    print "\n", `ls -ld / $dirlist`;
    if ($baddir) { print "File not found: $c_red$baddir$c_end\n"; $err = 1; }
  }

  if ($flag_l or $flag_d) {
    if (not @params and not $flag_s) { print "\n"; }
    if (@params and $flag_s) { print "\n"; }
  } else {
    # print absolute path to file
    my $ap = join "/", @left;
    if ($flag_r)    { print $links[0], "\n"; }
    if (not -e $ap) { print "File not found: $c_red$ap$c_end\n"; $err = 1; }
    else            { print "$ap\n"; }
  }
}

exit $err;
