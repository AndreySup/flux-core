#!/usr/bin/lua

-------------------------------------------------------------------------------
-- Modules:
-------------------------------------------------------------------------------
local posix = require 'posix'
local flux = require 'flux'
local timer = require 'timer'

local prog = string.match (arg[0], "([^/]+)$")
local shortprog = prog:match ("flux%-(.+)$")

-------------------------------------------------------------------------------
-- Program options
-------------------------------------------------------------------------------
function parse_cmdline (arg)
    local getopt = require 'alt_getopt' .get_opts
    local opt_table = {
        ['help']            = "h",
        ['ntasks']          = "n",
        ['nprocs-per-node'] = "N",
    }
    local optstring = "hn:N:"
    return getopt (arg, optstring, opt_table)
end

-------------------------------------------------------------------------------
-- Local functions:
-------------------------------------------------------------------------------
local function usage ()
    io.stderr:write ("Usage: "..prog.." [-n ntasks] COMMANDS...\n")
    io.stderr:write ([[
  -h, --help                 Display this message
  -n, --ntasks=N             Request to run a total of N tasks
  -N, --nprocs-per-node=N    Run at most N processes per node
]])
end

local function usage_and_exit (n)
    usage()
    os.exit (n or 0)
end

local function log_msg (...)
    io.stderr:write (shortprog..": " .. string.format (...))
end

local function log_fatal (...)
    log_msg (...)
    os.exit (1)
end

--
--  Check that parameter [a] is an integer
--
local function is_integer (a)
    local b = tonumber (a)
    return (type (b) == "number") and (math.floor(b) == b)
end

---
--  Get the LWJ return code as highest of all task return codes
---
local function lwj_return_code (f, id)
    local hostlist = require 'hostlist'
    local lwj = f:kvsdir ("lwj.%d", id)
    local max = 0
    local msgs = {}
    for taskid in lwj:keys () do
        if is_integer (taskid) then
            local t = lwj[taskid]
            local x = t.exit_status
            if x > 0 then
                local s = "exited with " ..
                          (t.exit_code and "exit code" or "signal") ..
                          " %d\n"
                s = s:format(t.exit_code or t.exit_sig)
                if not msgs[s] then
                    msgs[s] = hostlist.new(taskid)
                else
                    msgs[s]:concat (taskid)
                end
            end
            if x > max then
                max = x
            end
        end
    end
    for s,h in pairs (msgs) do
        log_msg ("tasks %s: %s\n", tostring (h:sort()), s)
    end
    return max
end

--
-- Get the current env with some env vars filtered out:
--
local function get_filtered_env ()
    local env = posix.getenv()
    env.HOSTNAME = nil
    env.ENVIRONMENT = nil
    for k,v in pairs (env) do
        if k:match ("SLURM_") then env[k] = nil end
    end
    return (env)
end

-------------------------------------------------------------------------------
-- Main program:
-------------------------------------------------------------------------------
--  Parse cmdline args:
--
local terminate = false
local sigtimer

local opts, optind = parse_cmdline (arg)
if opts.h then usage_and_exit () end
if optind > #arg then
    log_msg ("Error: remote command required\n")
    usage_and_exit (1)
end

local ntasks = tonumber (opts.n) or 1
local ppn    = opts.N and tonumber (opts.N) or nil
local cmdline = {}
for i = optind, #arg do
    table.insert (cmdline, arg[i])
end

-- Set signal handlers
posix.signal[posix.SIGINT] = function () terminate = true end
posix.signal[posix.SIGTERM] = posix.signal[posix.SIGINT]

-- Start in-program timer:
local tt = timer.new()

--  Create new connection to local cmbd:
--
local f, err = flux.new()
if not f then log_fatal ("flux.new: %s\n", err) end

--
--  Create a job request as Lua table:
--
local jobreq = {
      ntasks             = ntasks,
      ['tasks-per-node'] = ppn,
      cmdline            = cmdline,
      environ            = get_filtered_env(),
      cwd                = posix.getcwd(),
}

log_msg ("%4.03fs: Sending LWJ request for %d tasks (cmdline \"%s\")\n",
    tt:get0(), ntasks, table.concat (cmdline, ' '))

--
--  Send job request message with tag="job.create"
--
local resp, err = f:rpc ('job.create', jobreq)
if not resp then log_fatal ("flux.rpc: %s\n", err) end

if resp.errnum then
    log_fatal ("job.create message failed with errnum=%d\n", resp.errnum)
end

log_msg ("%4.03fs: Submitted jobid %d\n", tt:get0(), resp.jobid)

--
--  Get a handle to this lwj kvsdir:
--
local lwj, err = f:kvsdir ("lwj.%d", resp.jobid)
if not lwj then log_fatal ("f:kvsdir(lwj.%d): %s\n", resp.jobid, err) end

-- vi: ts=4 sw=4 expandtab
