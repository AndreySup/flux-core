1. Launching the framework

Use the ./scripts/launch script to start the framework in a slurm job.
It will work with or without a pre-existing slurm allocation.

   ./scripts/launch [-c NAME] [-n nnodes]

The -c option selects a pepe config other than the default (flat).
The -n option specifies the number of nodes.  If running inside a slurm
allocation, the default number of nodes is the entire allocation.

There are several pepe config files for different test topologies.

binary
	Binary (k=2) tree with no resiliency.

binomial
	Binomial tree with no resilency.

degenerate
	Degenerate (k=1) tree with no resilency.

flat
	Flat (k=N) tree with no resilency.

trinary
	Trinary (k=3) tree with resiliency (grandparent is backup parent)

2. Events

There are two unrelated message flows: one for events, and one for requests.
Events utilize pub-sub with hiericical topic names.  One (un)subscribes to
a topic by substring.  For example, subscribing to "event.live." matches
"event.live.up.42" and "event.live.down.24".  Examples:

event.sched.trigger.<epoch>
event.live.up.<node>
event.live.down.<node>
event.route.update
event.barrier.exit.<name>

An event message consists of just one frame:

+------------+
| topic name |
+------------+

Between nodes, cmbd instances communicate events over EPGM reliable
multicast.  Within a node, the cmbd and plugins communicate events over
shared memory.  The cmbd relays event messages received on EPGM to all local
plugins, and event messages received from plugins to other plugins and EPGM.

3. Requests

Requests are messages addressed to a particular plugin, which may
respond with zero or more reply messages.   The core of a request consists
of two frames:

+------------+
| topic name |
+------------+
|    JSON    |
+------------+

The topic name is formatted like an event topic name and is used to
address a request to a plugin.  For example, a request with the topic
name "kvs.set" would be addressed to the kvs plugin, and "set" is 
interpreted internally by the kvs plugin as a method.  The JSON frame
contains input paramters for the method.

Request messages accumulate address frames as they are passed through
routers.  The resulting stack of address frames is then used by the
destination to route responses back to the sender.  For example, a
session is organized in a binary tree as follows:

    0
  1   2
 3 4 5 6

If an api client on 3 wants to send a message to kvs.set on 0, it sends
to its cmbd which prepends '3' and sends the message to 1.  1 prepends '1'
and sends the message to 0.  This is delivered ot the kvs plugin on 0.  

                              +---------+
                              |    1    |
               +---------+    +---------+
               |     3   |    |    3    |
+---------+    +---------+    +---------+
| kvs.set |    | kvs.set |    | kvs.set |
+---------+    +---------+    +---------+
|   JSON  |    |   JSON  |    |   JSON  |
+---------+    +---------+    +---------+

When the kvs plugin replies, it replaces/augments the JSON frame,
leaves the topic field intact, then sends the message to its cmbd,
which strips the top frame off and delivers the message to 1, which
strips the top frame off and delivers to 3.

Each node has a route hash contianing the ranks of its children in
the overlay tree, and the names of its loaded plugins.  The hash is
consulted to decide whether a request or response should be delivered
"down" to a local plugin, "down" to a child node, or, if the name of
the desitnation plugin or node could not be found in the hash, "up" towards
the tree root.  Thus it is possible to have routes installed
that allow requests and responses to traverse the tree between any pair
of nodes, and unknown destinations are passed up towards the root until
they are matched by a node's route hash.  If that doesn't happen they
are sent an ENOSYS reply by the root.

There is an additional "fully qualified" topic string format that allows
the destination node to be prepended, e.g. "42!kvs.set" refers to the kvs
plugin on node 42.

4. Ping

Every plugin has a built-in "ping" method which allows round-trip request
latency to be measured to a plugin.  In this example, the ping utility
is run on node 0 and sends packets through a degenerate tree (k=1) to the
'live' plugin on node 2:

./cmbutil --ping '2!live'
cmbutil: 2!live.ping pad=0 seq=0 time=1.285 ms (2!1!0)
cmbutil: 2!live.ping pad=0 seq=1 time=1.414 ms (2!1!0)
cmbutil: 2!live.ping pad=0 seq=2 time=1.299 ms (2!1!0)
cmbutil: 2!live.ping pad=0 seq=3 time=1.416 ms (2!1!0)
cmbutil: 2!live.ping pad=0 seq=4 time=1.575 ms (2!1!0)
^C

This shows the round-trip-time in milleconds, as well as the route
taken by the reply.
