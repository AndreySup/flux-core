#!/usr/bin/lua

-------------------------------------------------------------------------------
-- Modules:
-------------------------------------------------------------------------------
local posix = require 'posix'
local flux = require 'flux'
local timer = require 'timer'

local prog = string.match (arg[0], "([^/]+)$")
local shortprog = prog:match ("flux%-(.+)$")


-------------------------------------------------------------------------------
-- Local functions:
-------------------------------------------------------------------------------
--
--  Check that parameter [a] is an integer --
local function is_integer (a)
    local b = tonumber (a)
    return (type (b) == "number") and (math.floor(b) == b)
end

---
--  Get the LWJ return code as highest of all task return codes
---
local function lwj_return_code (f, wreck, id)
    local hostlist = require 'hostlist'
    local lwj = f:kvsdir ("lwj.%d", id)
    local max = 0
    local msgs = {}
    for taskid in lwj:keys () do
        if is_integer (taskid) then
            local t = lwj[taskid]
            local x = t.exit_status
            if x > 0 then
                local s = "exited with " ..
                          (t.exit_code and "exit code" or "signal") ..
                          " %d\n"
                s = s:format(t.exit_code or t.exit_sig)
                if not msgs[s] then
                    msgs[s] = hostlist.new(taskid)
                else
                    msgs[s]:concat (taskid)
                end
            end
            if x > max then
                max = x
            end
        end
    end
    for s,h in pairs (msgs) do
        wreck:say ("tasks %s: %s\n", tostring (h:sort()), s)
    end
    return max
end

local function summarize_tasks_per_node (r)
    local hostlist = require 'hostlist'
    local m = {}
    for msg, ids in pairs (r) do
        local h = hostlist.new()
        for _,id in pairs (ids) do
            h:concat (id)
        end
        table.insert (m, string.format ("node%s: %s", tostring (h:sort()), msg))
    end
    return table.concat (m, ', ')
end

local function fake_resource_array (wreck, nnodes)
    local res = {}
    local total = 0
    local ppn = wreck.tasks_per_node or (wreck.ntasks / nnodes)
    for i = 0, nnodes - 1 do
        local n = ppn
        if (total + ppn) > wreck.ntasks then
            n = wreck.ntasks - total
        end
        res[i] = { cores = n }
        total = total + n
    end
    return res
end

local function alloc_tasks_hack (f, wreck, lwj)
    local r = {}
    local total = 0
    local size = f.size
    local res


    if (wreck.tasks_per_node or wreck.nnodes) then
        if wreck.ntasks == 1 then
            if wreck.tasks_per_node then
                if wreck.nnodes then
                    wreck.ntasks = wreck.tasks_per_node * wreck.nnodes
                else
                    wreck.ntasks = wreck.tasks_per_node * f.size
                end
            else
                wreck.ntasks = wreck.nnodes
            end
        end
        res = fake_resource_array (wreck, wreck.nnodes or f.size)
    else
        res, err = f:kvsdir ("resrc.rank")
        if not res then
            wreck:die ("Failed to get resrc.rank")
        end
    end

    wreck:say ("Allocating %d tasks across %d available nodes..\n",
                wreck.ntasks, size)

    for i = 0, size-1 do
        local key = "rank."..i..".cores"
        local n = res[i].cores
        if (total + n) > wreck.ntasks then
           n = wreck.ntasks - total
        end
        lwj[key] = n
        if r[n] then table.insert (r[n], i) else r[n] = { i } end
        total = total + n
        if total == wreck.ntasks then break end
    end
    lwj:commit()
    wreck:say ("tasks per node: %s\n", summarize_tasks_per_node (r))
end

-------------------------------------------------------------------------------
-- Main program:
-------------------------------------------------------------------------------
--  Parse cmdline args:
--
local wreck = require 'wreck' .new (shortprog)
local terminate = false
local sigtimer

wreck:add_options ({
    { name = "tasks-per-node", char = "t", arg = "N",
        usage = "Force number of tasks per node" },
    { name = "nnodes", char = "N", arg = "N",
        usage = "Force number of nodes" },
    { name = 'now', char = 'i',
        usage = "Run job immediately" },
})

if not wreck:parse_cmdline (arg) then
    wreck:die ("Failed to process cmdline args\n")
end

-- Set signal handlers
posix.signal[posix.SIGINT] = function () terminate = true end
posix.signal[posix.SIGTERM] = posix.signal[posix.SIGINT]

-- Start in-program timer:
local tt = timer.new()

--  Create new connection to local cmbd:
--
local f, err = flux.new()
if not f then wreck:die ("Connecting to flux failed: %s\n", err) end

--
--  Create a job request as Lua table:
--
local jobreq = wreck:jobreq()

wreck:say ("%4.03fs: Sending LWJ request for %d tasks (cmdline \"%s\")\n",
    tt:get0(), wreck.ntasks, table.concat (wreck.cmdline, ' '))

--
--  Send job request message with tag="job.create"
--
local resp, err = f:rpc ('job.create', jobreq)
if not resp then wreck:die ("flux.rpc: %s\n", err) end

if resp.errnum then
    wreck:die ("job.create message failed with errnum=%d\n", resp.errnum)
end

wreck:say ("%4.03fs: Registered jobid %d\n", tt:get0(), resp.jobid)

--
--  Get a handle to this lwj kvsdir:
--
local lwj, err = f:kvsdir ("lwj.%d", resp.jobid)
if not lwj then wreck:die ("f:kvsdir(lwj.%d): %s\n", resp.jobid, err) end

if wreck:getopt ("i") then
    --
    --  Send event to run the job
    --
    wreck.nnodes = wreck:getopt ("N")
    wreck.tasks_per_node = wreck:getopt ("t")
    alloc_tasks_hack (f, wreck, lwj)
    wreck:say ("%-4.03fs: Sending run event\n", tt:get0())
    local rc,err = f:sendevent ("event.rexec.run.%d", resp.jobid)
    if not rc then wreck:die ("sendevent: %s\n", err) end
else
    --
    --  Update job state to 'pending' to notify scheduler:
    --
    lwj.state = 'pending'
    lwj['pending-time'] = posix.strftime ("%FT%T")
    lwj:commit()
end

local sigtimer = nil
repeat
 local r,err = lwj:watch ("state", r)
 if r then wreck:say ("%-4.03fs: State = %s\n", tt:get0(), r) end

 if not r then wreck:say ("%s\n", err) end

 --
 --  If we catch a signal then lwj:watch() will be interrupted.
 --   Check to see if we should terminate the job now:
 --
 if terminate then
    wreck:say ("%4.03fs: Killing LWJ %d\n", tt:get0(), resp.jobid)
    local rc,err = f:sendevent ("event.rexec.kill.%d", resp.jobid)
    if not rc then
        wreck:say ("Error: Failed to send kill event: %s", err)
    end
    if not sigtimer then
       sigtimer = timer.new()
    else
       if sigtimer:get() < 1.0 then
         wreck:say ("Detaching from job. Processes may still be running\n");
         os.exit (0);
       end
    end
    terminate = false
 end
until r == "complete"

local rc = lwj_return_code (f, wreck, resp.jobid)
if rc == 0 then
    wreck:say ("All tasks completed successfully.\n");
end


-- vi: ts=4 sw=4 expandtab
